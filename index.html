<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Light Mesh — Numbers + Lines + Record</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root { color-scheme: dark; }
  html,body { margin:0; height:100%; background:#000; overflow:hidden; font-family: "Inter", sans-serif; }
  #wrap { position:relative; width:100vw; height:100dvh; touch-action:none; }
  video#cam { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
  canvas#hud, canvas#glow { position:absolute; inset:0; pointer-events:none; }
  
  #top-ui {
    position:absolute; top:12px; right:12px; z-index:4;
    display:flex; gap:8px; align-items:center;
  }

  /* Pair controls on a single row and make them span full grid width */
.inline-controls {
  grid-column: 1 / -1;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap; /* wrap nicely on small screens */
}
.inline-controls input[type="range"] {
  width: 160px;         /* comfortable default */
  max-width: 40vw;      /* responsive */
}


  .ui {
    position:absolute; left:0; right:0; bottom:0; padding:10px 12px;
    background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.6) 30%, rgba(0,0,0,.9) 100%);
    display:flex; flex-direction:column; align-items:center; gap:10px;
    color:#9fe1ff; z-index:3;
  }
  #sliderPanel {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px 24px;
    justify-items: start;
    padding: 0 10%;
    max-height: 0;
    overflow: hidden;
    transition: max-height .4s ease-out, padding .4s ease-out;
    width: 100%;
    box-sizing: border-box;
  }
  .ui.open #sliderPanel {
    max-height: 40dvh;
    overflow-y: auto;
    padding-top: 10px;
    padding-bottom: 10px;
  }

  .ui label { display:flex; align-items:center; gap:8px; font-size:12px; white-space:nowrap; }
  .ui input[type=range] { width:22vw; max-width:180px; }
  .btn {
    background: transparent; border: 1px solid #2aa9d9; padding: 8px 12px;
    border-radius: 10px; color: #c9f3ff; cursor: pointer; font-size: 12px;
    font-weight: 600; transition: all 0.3s ease;
  }
  .btn:hover { background: #2aa9d9; color: #001f29; }
  .btn.rec { border-color:#ff5555; }
  .btn.rec:hover { background: #ff5555; color: #2a0000; }
  .btn[disabled] { opacity:.5 }
  select.color-selector {
    background:#02212b; color:#c9f3ff; border:1px solid #2aa9d9;
    padding:6px; border-radius:8px;
  }
</style>
</head>
<body>

<div id="top-ui">
  <button class="btn" id="flip">Flip Cam</button>
  <button class="btn rec" id="recBtn">● Record</button>
</div>

<div id="wrap">
  <video id="cam" autoplay playsinline muted></video>
  <canvas id="glow"></canvas>
  <canvas id="hud"></canvas>

  <div class="ui">
    <div id="sliderPanel">
      <label>Text:<select id="textColorSel" class="color-selector"></select></label>
      <label>Line:<select id="lineColorSel" class="color-selector"></select></label>

      <!-- NEW: Contrast control (50%–200%) -->
      <label>Contrast:<input id="contrast" type="range" min="50" max="200" value="120" step="5"></label>

      <label>Threshold:<input id="thr" type="range" min="100" max="700" value="250" step="5"></label>
      <label>Motion:<input id="mot" type="range" min="0" max="60" value="30" step="1"></label>
      <label>No. of pts:<input id="pts" type="range" min="4" max="40" value="16" step="1"></label>
      <label>Size:<input id="siz" type="range" min="0" max="24" value="10" step="1"></label>
      <label>No. of lines:<input id="lines" type="range" min="0" max="200" value="80" step="1"></label>
      <label>Link density:<input id="link" type="range" min="10" max="300" value="180" step="5"></label>
       <label class="inline-controls">
  <span>Windows:</span>
  <input id="windows" type="checkbox">
  <span>Size:</span>
  <input id="winSize" type="range" min="10" max="80" value="20" step="1">
</label>

<label class="inline-controls">
  <span>Blocks:</span>
  <input id="blocks" type="checkbox">
  <span>Size:</span>
  <input id="blkSize" type="range" min="10" max="80" value="20" step="1">
</label>


    </div>
    <button class="btn" id="controlsToggle">Controls</button>
  </div>
</div>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
(async function () {
  const vid  = document.getElementById('cam');
  const hud  = document.getElementById('hud');
  const glow = document.getElementById('glow');
  const ctx  = hud.getContext('2d');

  // sliders and controls
  const thr = document.getElementById('thr');
  const mot = document.getElementById('mot');
  const ptsSlider   = document.getElementById('pts');
  const sizSlider   = document.getElementById('siz');
  const linesSlider = document.getElementById('lines');
  const linkSlider  = document.getElementById('link');
  const blocksCheckbox = document.getElementById('blocks');
  const windowsCheckbox = document.getElementById('windows');
  const blkSizeSlider = document.getElementById('blkSize');
  const winSizeSlider = document.getElementById('winSize');

  // NEW: Contrast slider + factor (0.5–2.0)
  const contrastSlider = document.getElementById('contrast');
  let contrastFactor = 1.2; // default 120%
  const contrastFromSlider = () => (parseInt(contrastSlider.value,10) / 100);
  contrastSlider.oninput = () => {
    contrastFactor = contrastFromSlider();
    // also style the preview for user visual feedback
    vid.style.filter = `contrast(${contrastFactor})`;
  };

  blocksCheckbox.onchange = () => { if (blocksCheckbox.checked) windowsCheckbox.checked = false; };
  windowsCheckbox.onchange = () => { if (windowsCheckbox.checked) blocksCheckbox.checked = false; };

  const uiContainer = document.querySelector('.ui');
  const controlsToggle = document.getElementById('controlsToggle');
  controlsToggle.onclick = () => {
    uiContainer.classList.toggle('open');
    controlsToggle.textContent = uiContainer.classList.contains('open') ? 'Close' : 'Controls';
  };

  const textColorSel = document.getElementById('textColorSel');
  const lineColorSel = document.getElementById('lineColorSel');
  const colorOptions = ['white','cyan','magenta','lime','red','yellow'];
  let textColor = 'white';
  let lineColor = 'white';

  function setupColorSelector(selectEl, callback) {
    colorOptions.forEach(c=>{const o=document.createElement('option');o.value=c;o.textContent=c;selectEl.appendChild(o);});
    selectEl.oninput = () => callback(selectEl.value);
  }
  setupColorSelector(textColorSel, (c) => textColor = c);
  setupColorSelector(lineColorSel, (c) => lineColor = c);
  
  // --- CAMERA SELECTION / FLIP FIX ---
  let facing = 'environment';
  let videoDevices = [];
  let currentDeviceId = null;

  async function refreshDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    videoDevices = devices.filter(d => d.kind === 'videoinput');
  }

  async function startCamera() {
    // stop old tracks
    if (vid.srcObject) vid.srcObject.getTracks().forEach(t => t.stop());

    // Try to pick by facingMode first; if that fails, fall back to deviceId rotation.
    let constraints = { video: { width:{ideal:1920}, height:{ideal:1080}, facingMode: facing }, audio: false };

    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      vid.srcObject = stream; await vid.play();
      await refreshDevices();

      // try to record which deviceId we got (when available)
      const track = stream.getVideoTracks()[0];
      const settings = track.getSettings ? track.getSettings() : {};
      currentDeviceId = settings.deviceId || currentDeviceId;

    } catch (e) {
      // facingMode not honored -> fallback to cycling deviceId
      await refreshDevices();
      if (videoDevices.length) {
        // heuristic: pick first for "environment", last for "user" if labels are available
        const back = videoDevices.find(d => /back|rear|environment/i.test(d.label));
        const front = videoDevices.find(d => /front|user/i.test(d.label));
        const pick = (facing === 'user') ? (front || videoDevices[0]) : (back || videoDevices[videoDevices.length-1]);

        const stream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: pick.deviceId, width:{ideal:1920}, height:{ideal:1080} },
          audio: false
        });
        vid.srcObject = stream; await vid.play();
        currentDeviceId = pick.deviceId;
      }
    }

    // mirror preview for selfie cam
    vid.style.transform = (facing === 'user') ? 'scaleX(-1)' : 'none';
    // keep contrast effect applied on restart
    vid.style.filter = `contrast(${contrastFactor})`;
  }

  await startCamera();

  document.getElementById('flip').onclick = async () => {
    // toggle logical facing
    facing = (facing === 'user' ? 'environment' : 'user');
    await startCamera();
  };

  // --- RENDER / DETECTION SETUP ---
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d',{willReadFrequently:true});
  const renderer = new THREE.WebGLRenderer({canvas:glow,alpha:true});
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(0,innerWidth,innerHeight,0,-10,10);

  const recCanvas = document.createElement('canvas');
  const recCtx    = recCanvas.getContext('2d');
  const recBtn    = document.getElementById('recBtn');
  let mediaRecorder=null, recordedBlobs=[], isRecording=false;

  function resize(){
    const w=innerWidth,h=innerHeight;
    glow.width=hud.width=w; glow.height=hud.height=h;
    proc.width=proc.height=224;
    renderer.setSize(w,h,false);
    camera.right=w; camera.bottom=h; camera.updateProjectionMatrix();
    recCanvas.width=w; recCanvas.height=h;
  }
  resize(); window.onresize=resize;

  const texCanvas=document.createElement('canvas'); texCanvas.width=texCanvas.height=64;
  const g=texCanvas.getContext('2d');
  const grad=g.createRadialGradient(32,32,1,32,32,28);
  grad.addColorStop(0,'rgba(255,255,220,1)');
  grad.addColorStop(.4,'rgba(255,220,120,.8)');
  grad.addColorStop(1,'rgba(255,220,120,0)');
  g.fillStyle=grad; g.fillRect(0,0,64,64);
  const tex=new THREE.CanvasTexture(texCanvas);
  const mat=new THREE.SpriteMaterial({map:tex,transparent:true,blending:THREE.AdditiveBlending});
  const MAX=60;
  const sprites=Array.from({length:MAX},()=>{const s=new THREE.Sprite(mat.clone());s.scale.set(14,14,1);scene.add(s);return s;});
  const smooth=Array.from({length:MAX},()=>({x:0,y:0,ok:false}));
  const ema=0.94; let bg=null;

  // FIXED: cover draw typo (tAsp calculation)
  function coverDrawVideo(ctx, targetW, targetH, mirror=false){
    const vW=vid.videoWidth, vH=vid.videoHeight; if(!vW||!vH) return;
    const vAsp = vW / vH, tAsp = targetW / targetH;   // <-- fixed
    let drawW, drawH;
    if (tAsp>vAsp){ drawW=targetW; drawH=targetW/vAsp; } else { drawH=targetH; drawW=targetH*vAsp; }
    const offX=(targetW-drawW)/2, offY=(targetH-drawH)/2;
    ctx.save();
    ctx.translate(offX + (mirror?drawW:0), offY);
    ctx.scale(mirror?-1:1, 1);
    ctx.drawImage(vid, 0, 0, drawW, drawH);
    ctx.restore();
  }

  function mapToScreen(px,py){
    const w=hud.width,h=hud.height,vW=vid.videoWidth,vH=vid.videoHeight;
    const vAsp=vW/vH,vwAsp=w/h; let drawW,drawH;
    if(vwAsp>vAsp){drawW=w;drawH=w/vAsp;} else {drawH=h;drawW=h*vAsp;}
    const offX=(w-drawW)/2, offY=(h-drawH)/2;
    const nx=px/proc.width, ny=py/proc.height;
    const mirror=(facing==='user')?(1-nx):nx;
    return {x:offX+drawW*mirror, y:offY+drawH*ny};
  }

  const detectionBlockSize = 8;
  
  // --- Reusable Drawing Functions ---
  function drawLines(targetCtx, points) {
      targetCtx.save();
      targetCtx.strokeStyle = lineColor;
      targetCtx.globalAlpha = 0.55;
      targetCtx.lineWidth = 0.6;
      const n = points.length, maxLines = +linesSlider.value, maxDist = +linkSlider.value;
      for (let k = 0; k < maxLines && n > 1; k++) {
          const i = (Math.random() * n) | 0, j = (Math.random() * n) | 0;
          if (i === j) continue;
          const ax = points[i].sx, ay = points[i].sy, bx = points[j].sx, by = points[j].sy;
          const dx = ax - bx, dy = ay - by;
          if (dx * dx + dy * dy > maxDist * maxDist) continue;
          targetCtx.beginPath();
          targetCtx.moveTo(ax, ay);
          targetCtx.lineTo(bx, by);
          targetCtx.stroke();
      }
      targetCtx.restore();
  }
  
  function drawWindows(targetCtx, points) {
      const w = targetCtx.canvas.width, h = targetCtx.canvas.height;
      const vW = vid.videoWidth, vH = vid.videoHeight;
      const vAsp = vW / vH, tAsp = w / h;
      let drawW, drawH;
      if (tAsp > vAsp) { drawW = w; drawH = w / vAsp; } else { drawH = h; drawW = h * vAsp; }
      const offX = (w - drawW) / 2, offY = (h - drawH) / 2;
      const ratioX = vW / drawW, ratioY = vH / drawH;
      const winSize = parseFloat(winSizeSlider.value);

      for (const p of points) {
          const destX = p.sx - winSize / 2, destY = p.sy - winSize / 2;
          const sourceSizeX = winSize * ratioX, sourceSizeY = winSize * ratioY;
          const sourceX = (p.sx - offX) * ratioX - sourceSizeX / 2;
          const sourceY = (p.sy - offY) * ratioY - sourceSizeY / 2;
          targetCtx.drawImage(vid, sourceX, sourceY, sourceSizeX, sourceSizeY, destX, destY, winSize, winSize);
      }
  }

  function drawBlocks(targetCtx, points) {
      targetCtx.strokeStyle = lineColor;
      targetCtx.lineWidth = 0.8;
      const blkSize = parseFloat(blkSizeSlider.value);
      for (const p of points) {
          const x = p.sx - blkSize / 2, y = p.sy - blkSize / 2;
          targetCtx.strokeRect(x, y, blkSize, blkSize);
          targetCtx.beginPath();
          targetCtx.moveTo(x, y); targetCtx.lineTo(x + blkSize, y + blkSize);
          targetCtx.moveTo(x + blkSize, y); targetCtx.lineTo(x, y + blkSize);
          targetCtx.stroke();
      }
  }

  function drawNumbers(targetCtx, points) {
      const fontSize = parseFloat(sizSlider.value);
      if (fontSize <= 0) return;
      targetCtx.fillStyle = textColor;
      targetCtx.font = `${fontSize}px ui-monospace, monospace`;
      for (const p of points) {
          const text = p.code, tw = targetCtx.measureText(text).width;
          targetCtx.save();
          targetCtx.shadowColor = 'rgba(0,0,0,0.8)';
          targetCtx.shadowBlur = 5;
          targetCtx.fillText(text, p.sx - tw / 2, p.sy + (fontSize / 2.5));
          targetCtx.restore();
      }
  }
  
  // Main HUD drawing function for display
  function drawHUD(points) {
    const w=hud.width,h=hud.height;
    ctx.clearRect(0,0,w,h);

    if (windowsCheckbox.checked) {
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(0, 0, w, h);
    }
    
    drawLines(ctx, points);

    if (windowsCheckbox.checked) {
        drawWindows(ctx, points);
    } else if (blocksCheckbox.checked) {
        drawBlocks(ctx, points);
    }

    if (!blocksCheckbox.checked) {
        drawNumbers(ctx, points);
    }
  }

  function randCode(){return (1000+Math.floor(Math.random()*9000)).toString();}

  function startRecording(){
    recordedBlobs=[];
    const stream = recCanvas.captureStream(30);
    const mime = MediaRecorder && MediaRecorder.isTypeSupported
      ? (MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9'
         : (MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm'))
      : null;
    if (!window.MediaRecorder || !mime){
      alert('Recording not supported on this browser. Use Android/Chrome or use system screen recording.');
      return;
    }
    mediaRecorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 5_000_000 });
    mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedBlobs.push(e.data); };
    mediaRecorder.onstop = ()=>{
      const blob = new Blob(recordedBlobs, { type: 'video/webm' });
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement('a');
      a.href=url; a.download=`lightmesh_${Date.now()}.webm`; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    };
    mediaRecorder.start();
    isRecording=true; recBtn.textContent='■ Stop';
  }
  function stopRecording(){
    if(mediaRecorder && isRecording) mediaRecorder.stop();
    isRecording=false; recBtn.textContent='● Record';
  }
  recBtn.onclick = ()=> isRecording ? stopRecording() : startRecording();

  const texSize = 224;

  // Linear contrast adjust helper for detection (affects pctx pixels)
  function applyContrast(v /*0..255*/, c /*0.5..2.0*/) {
    // center at 128, scale, clamp
    let out = 128 + (v - 128) * c;
    if (out < 0) out = 0; else if (out > 255) out = 255;
    return out;
  }

  async function tick(){
    if(vid.readyState>=2){
      // draw into processing canvas (square crop)
      const s=Math.min(vid.videoWidth,vid.videoHeight);
      pctx.drawImage(vid,(vid.videoWidth-s)/2,(vid.videoHeight-s)/2,s,s,0,0,texSize,texSize);
      const frame=pctx.getImageData(0,0,texSize,texSize).data;
      if(!bg) bg=new Uint8ClampedArray(texSize*texSize);
      const gray=new Uint8ClampedArray(texSize*texSize);

      // compute grayscale then apply contrast factor for detection pipeline
      const cfac = contrastFactor; // 0.5..2.0
      for(let i=0,j=0;i<frame.length;i+=4,j++){
        const g = (frame[i]+frame[i+1]+frame[i+2])/3;
        gray[j] = applyContrast(g, cfac);
      }

      // EMA background
      for(let j=0;j<gray.length;j++) bg[j]=bg[j]*ema + gray[j]*(1-ema);

      const brightThr=+thr.value, motThr=+mot.value;

      const motion=new Uint8ClampedArray(gray.length);
      for(let j=0;j<gray.length;j++){ const d=Math.abs(gray[j]-bg[j]); motion[j]=d>motThr?255:0; }

      const mask=new Uint8ClampedArray(gray.length);
      for(let j=0;j<gray.length;j++){ mask[j]=(gray[j]*3>brightThr && motion[j])?1:0; }

      const want=Math.min(+ptsSlider.value,MAX);
      const bs=detectionBlockSize; const picks=[];
      for(let by=0;by<texSize;by+=bs){
        for(let bx=0;bx<texSize;bx+=bs){
          let best=-1,bxBest=0,byBest=0;
          for(let y=by;y<by+bs&&y<texSize;y++){
            for(let x=bx;x<bx+bs&&x<texSize;x++){
              const j=y*texSize+x; if(!mask[j]) continue;
              const v=gray[j]; if(v>best){best=v;bxBest=x;byBest=y;}
            }
          }
          if(best>=0)picks.push({x:bxBest,y:byBest,v:best,bx:bx,by:by});
        }
      }
      picks.sort((a,b)=>b.v-a.v);
      const pts=picks.slice(0,want);

      const alpha=0.3;
      for(let i=0;i<MAX;i++){
        const p=pts[i];
        if(p){
          const m=mapToScreen(p.x,p.y);
          if(!smooth[i].ok){smooth[i].x=m.x; smooth[i].y=m.y; smooth[i].ok=true; smooth[i].code=randCode();}
          smooth[i].x=smooth[i].x*(1-alpha)+m.x*alpha;
          smooth[i].y=smooth[i].y*(1-alpha)+m.y*alpha;
          smooth[i].bx=p.bx; smooth[i].by=p.by;
          smooth[i].origX = p.x; smooth[i].origY = p.y;
          sprites[i].position.set(smooth[i].x,smooth[i].y,0);
          sprites[i].material.opacity=1;
          const size=parseFloat(sizSlider.value);
          sprites[i].scale.set(size*1.5, size*1.5, 1);
          if(Math.random()<0.02) smooth[i].code=randCode();
        } else {
          smooth[i].ok=false; sprites[i].material.opacity=0; sprites[i].position.set(-9999,-9999,0);
        }
      }

      renderer.render(scene,camera);
      const visible=smooth.filter(s=>s.ok).map(s=>({sx:s.x,sy:s.y,code:s.code,bx:s.bx,by:s.by, x:s.origX, y:s.origY}));
      
      glow.style.display = windowsCheckbox.checked ? 'none' : 'block';
      drawHUD(visible);

      if (isRecording){
          recCtx.clearRect(0, 0, recCanvas.width, recCanvas.height);
          if (windowsCheckbox.checked) {
              recCtx.fillStyle = 'rgba(0,0,0,0.85)';
              recCtx.fillRect(0, 0, recCanvas.width, recCanvas.height);
              drawLines(recCtx, visible);
              drawWindows(recCtx, visible);
              drawNumbers(recCtx, visible);
          } else {
              coverDrawVideo(recCtx, recCanvas.width, recCanvas.height, facing === 'user');
              recCtx.drawImage(glow, 0, 0);
              recCtx.drawImage(hud, 0, 0);
          }
      }
    }
    requestAnimationFrame(tick);
  }
  tick();
})();
</script>
</body>
</html>


